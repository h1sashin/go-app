package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"

	"github.com/h1sashin/go-app/db"
	"github.com/h1sashin/go-app/graph/public/generated"
	"github.com/h1sashin/go-app/graph/public/mapper"
	"github.com/h1sashin/go-app/graph/public/model"
	translator "github.com/h1sashin/go-app/i18n"
	"github.com/h1sashin/go-app/service"
	"github.com/nicksnyder/go-i18n/v2/i18n"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

func (r *mutationResolver) RefreshTokens(ctx context.Context, refreshToken string) (*model.Tokens, error) {
	loc := translator.ExtractLocalizer(ctx)

	tokens, err := r.AuthService.RefreshTokens(ctx, refreshToken)
	if err != nil {
		if err == service.ErrUnauthorized {
			return nil, &gqlerror.Error{Message: loc.MustLocalize(&i18n.LocalizeConfig{MessageID: "common.unauthorized"}), Extensions: map[string]interface{}{"code": "UNAUTHORIZED"}}
		}
	}

	return mapper.MapTokens(tokens), nil
}

func (r *mutationResolver) SignIn(ctx context.Context, email string, password string) (model.SignInResult, error) {
	fmt.Printf("email: %s, password: %s\n", email, password)
	loc := translator.ExtractLocalizer(ctx)

	user, tokens, err := r.AuthService.SignIn(ctx, email, password)
	if err != nil {
		if err == service.ErrNotFound {
			return model.SignInError{Code: model.SignInErrorCodeInvalidCredentials, Message: loc.MustLocalize(&i18n.LocalizeConfig{MessageID: "auth.invalid_credentials"})}, nil
		}
		if err == service.ErrUnauthorized {
			return model.SignInError{Code: model.SignInErrorCodeInvalidCredentials, Message: loc.MustLocalize(&i18n.LocalizeConfig{MessageID: "auth.invalid_credentials"})}, nil
		}
		return nil, &gqlerror.Error{Message: loc.MustLocalize(&i18n.LocalizeConfig{MessageID: "common.internal_error"}), Extensions: map[string]interface{}{"code": "INTERNAL_SERVER_ERROR"}}
	}

	return model.SignInSuccess{User: mapper.MapUser(user), Tokens: mapper.MapTokens(tokens)}, nil
}

func (r *mutationResolver) SignUp(ctx context.Context, email string, password string) (model.SignUpResult, error) {
	fmt.Printf("email: %s, password: %s\n", email, password)
	loc := translator.ExtractLocalizer(ctx)

	user, tokens, err := r.AuthService.SignUp(ctx, email, password, db.RoleUser)
	if err != nil {
		if err == service.ErrConflict {
			return model.SignUpError{Code: model.SignUpErrorCodeEmailAlreadyRegistered, Message: loc.MustLocalize(&i18n.LocalizeConfig{MessageID: "auth.already_exists"})}, nil
		}
		return nil, &gqlerror.Error{Message: loc.MustLocalize(&i18n.LocalizeConfig{MessageID: "common.internal_error"}), Extensions: map[string]interface{}{"code": "INTERNAL_SERVER_ERROR"}}
	}

	return model.SignUpSuccess{User: mapper.MapUser(user), Tokens: mapper.MapTokens(tokens)}, nil
}

func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
